// generated by "charlatan -output=test/charlatan/reader.go -package=charlatan io.Reader".  DO NOT EDIT.

package charlatan

import "reflect"

// ReaderReadInvocation represents a single call of FakeReader.Read
type ReaderReadInvocation struct {
	Parameters struct {
		P []byte
	}
	Results struct {
		N   int
		Err error
	}
}

// NewReaderReadInvocation creates a new instance of ReaderReadInvocation
func NewReaderReadInvocation(p []byte, n int, err error) *ReaderReadInvocation {
	invocation := new(ReaderReadInvocation)

	invocation.Parameters.P = p

	invocation.Results.N = n
	invocation.Results.Err = err

	return invocation
}

// ReaderTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type ReaderTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeReader is a mock implementation of Reader for testing.
Use it in your tests as in this example:

	package example

	func TestWithReader(t *testing.T) {
		f := &charlatan.FakeReader{
			ReadHook: func(p []byte) (n int, err error) {
				// ensure parameters meet expectations, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeRead ...
		f.AssertReadCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeRead.
*/
type FakeReader struct {
	ReadHook func([]byte) (int, error)

	ReadCalls []*ReaderReadInvocation
}

// NewFakeReaderDefaultPanic returns an instance of FakeReader with all hooks configured to panic
func NewFakeReaderDefaultPanic() *FakeReader {
	return &FakeReader{
		ReadHook: func([]byte) (n int, err error) {
			panic("Unexpected call to Reader.Read")
		},
	}
}

// NewFakeReaderDefaultFatal returns an instance of FakeReader with all hooks configured to call t.Fatal
func NewFakeReaderDefaultFatal(t_sym1 ReaderTestingT) *FakeReader {
	return &FakeReader{
		ReadHook: func([]byte) (n int, err error) {
			t_sym1.Fatal("Unexpected call to Reader.Read")
			return
		},
	}
}

// NewFakeReaderDefaultError returns an instance of FakeReader with all hooks configured to call t.Error
func NewFakeReaderDefaultError(t_sym2 ReaderTestingT) *FakeReader {
	return &FakeReader{
		ReadHook: func([]byte) (n int, err error) {
			t_sym2.Error("Unexpected call to Reader.Read")
			return
		},
	}
}

func (f *FakeReader) Reset() {
	f.ReadCalls = []*ReaderReadInvocation{}
}

func (f_sym3 *FakeReader) Read(p []byte) (n int, err error) {
	if f_sym3.ReadHook == nil {
		panic("Reader.Read() called but FakeReader.ReadHook is nil")
	}

	invocation_sym3 := new(ReaderReadInvocation)
	f_sym3.ReadCalls = append(f_sym3.ReadCalls, invocation_sym3)

	invocation_sym3.Parameters.P = p

	n, err = f_sym3.ReadHook(p)

	invocation_sym3.Results.N = n
	invocation_sym3.Results.Err = err

	return
}

// SetReadStub configures Reader.Read to always return the given values
func (f_sym4 *FakeReader) SetReadStub(n int, err error) {
	f_sym4.ReadHook = func([]byte) (int, error) {
		return n, err
	}
}

// SetReadInvocation configures Reader.Read to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym5 *FakeReader) SetReadInvocation(calls_sym5 []*ReaderReadInvocation, fallback_sym5 func() (int, error)) {
	f_sym5.ReadHook = func(p []byte) (n int, err error) {
		for _, call_sym5 := range calls_sym5 {
			if reflect.DeepEqual(call_sym5.Parameters.P, p) {
				n = call_sym5.Results.N
				err = call_sym5.Results.Err

				return
			}
		}

		return fallback_sym5()
	}
}

// ReadCalled returns true if FakeReader.Read was called
func (f *FakeReader) ReadCalled() bool {
	return len(f.ReadCalls) != 0
}

// AssertReadCalled calls t.Error if FakeReader.Read was not called
func (f *FakeReader) AssertReadCalled(t ReaderTestingT) {
	t.Helper()
	if len(f.ReadCalls) == 0 {
		t.Error("FakeReader.Read not called, expected at least one")
	}
}

// ReadNotCalled returns true if FakeReader.Read was not called
func (f *FakeReader) ReadNotCalled() bool {
	return len(f.ReadCalls) == 0
}

// AssertReadNotCalled calls t.Error if FakeReader.Read was called
func (f *FakeReader) AssertReadNotCalled(t ReaderTestingT) {
	t.Helper()
	if len(f.ReadCalls) != 0 {
		t.Error("FakeReader.Read called, expected none")
	}
}

// ReadCalledOnce returns true if FakeReader.Read was called exactly once
func (f *FakeReader) ReadCalledOnce() bool {
	return len(f.ReadCalls) == 1
}

// AssertReadCalledOnce calls t.Error if FakeReader.Read was not called exactly once
func (f *FakeReader) AssertReadCalledOnce(t ReaderTestingT) {
	t.Helper()
	if len(f.ReadCalls) != 1 {
		t.Errorf("FakeReader.Read called %d times, expected 1", len(f.ReadCalls))
	}
}

// ReadCalledN returns true if FakeReader.Read was called at least n times
func (f *FakeReader) ReadCalledN(n int) bool {
	return len(f.ReadCalls) >= n
}

// AssertReadCalledN calls t.Error if FakeReader.Read was called less than n times
func (f *FakeReader) AssertReadCalledN(t ReaderTestingT, n int) {
	t.Helper()
	if len(f.ReadCalls) < n {
		t.Errorf("FakeReader.Read called %d times, expected >= %d", len(f.ReadCalls), n)
	}
}

// ReadCalledWith returns true if FakeReader.Read was called with the given values
func (f_sym6 *FakeReader) ReadCalledWith(p []byte) bool {
	for _, call_sym6 := range f_sym6.ReadCalls {
		if reflect.DeepEqual(call_sym6.Parameters.P, p) {
			return true
		}
	}

	return false
}

// AssertReadCalledWith calls t.Error if FakeReader.Read was not called with the given values
func (f_sym7 *FakeReader) AssertReadCalledWith(t ReaderTestingT, p []byte) {
	t.Helper()
	var found_sym7 bool
	for _, call_sym7 := range f_sym7.ReadCalls {
		if reflect.DeepEqual(call_sym7.Parameters.P, p) {
			found_sym7 = true
			break
		}
	}

	if !found_sym7 {
		t.Error("FakeReader.Read not called with expected parameters")
	}
}

// ReadCalledOnceWith returns true if FakeReader.Read was called exactly once with the given values
func (f_sym8 *FakeReader) ReadCalledOnceWith(p []byte) bool {
	var count_sym8 int
	for _, call_sym8 := range f_sym8.ReadCalls {
		if reflect.DeepEqual(call_sym8.Parameters.P, p) {
			count_sym8++
		}
	}

	return count_sym8 == 1
}

// AssertReadCalledOnceWith calls t.Error if FakeReader.Read was not called exactly once with the given values
func (f_sym9 *FakeReader) AssertReadCalledOnceWith(t ReaderTestingT, p []byte) {
	t.Helper()
	var count_sym9 int
	for _, call_sym9 := range f_sym9.ReadCalls {
		if reflect.DeepEqual(call_sym9.Parameters.P, p) {
			count_sym9++
		}
	}

	if count_sym9 != 1 {
		t.Errorf("FakeReader.Read called %d times with expected parameters, expected one", count_sym9)
	}
}

// ReadResultsForCall returns the result values for the first call to FakeReader.Read with the given values
func (f_sym10 *FakeReader) ReadResultsForCall(p []byte) (n int, err error, found_sym10 bool) {
	for _, call_sym10 := range f_sym10.ReadCalls {
		if reflect.DeepEqual(call_sym10.Parameters.P, p) {
			n = call_sym10.Results.N
			err = call_sym10.Results.Err
			found_sym10 = true
			break
		}
	}

	return
}
